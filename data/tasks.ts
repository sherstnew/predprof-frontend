import { Task, Difficulty, Subject } from '@/lib/types';

export const tasks: Task[] = [
  {
    _id: "alg_1",
    subject: Subject.inf,
    theme: "Алгоритмы",
    difficulty: Difficulty.easy,
    title: "Бинарный поиск",
    statement: "Реализуйте классический алгоритм бинарного поиска в отсортированном массиве целых чисел. Функция должна принимать отсортированный массив и целевой элемент, возвращать индекс первого вхождения элемента или -1, если элемент не найден. Учитывайте, что массив отсортирован в неубывающем порядке, и обработайте случаи пустого массива или дубликатов элементов."
  },
  {
    _id: "alg_3",
    subject: Subject.inf,
    theme: "Алгоритмы",
    difficulty: Difficulty.hard,
    title: "Алгоритм Дейкстры",
    statement: "Найдите кратчайшие пути от заданной стартовой вершины до всех остальных вершин во взвешенном графе без ребер с отрицательными весами. Граф представлен в виде списка смежности с весами ребер. Используйте приоритетную очередь для оптимизации, верните массив дистанций и, опционально, массив предшественников для восстановления путей. Обработайте случаи, когда граф не связный."
  },
  {
    _id: "alg_4",
    subject: Subject.inf,
    theme: "Алгоритмы",
    difficulty: Difficulty.easy,
    title: "Числа Фибоначчи",
    statement: "Напишите функцию, вычисляющую n-ое число Фибоначчи (где F(0) = 0, F(1) = 1) с использованием итеративного подхода для оптимизации памяти (O(1) дополнительной памяти). Функция должна принимать неотрицательное целое n и возвращать соответствующее число Фибоначчи. Учитывайте большие значения n, где результат может быть большим числом, и используйте подходящий тип данных (например, BigInt в JavaScript)."
  },
  {
    _id: "alg_5",
    subject: Subject.inf,
    theme: "Алгоритмы",
    difficulty: Difficulty.medium,
    title: "Поиск подстроки (КМП)",
    statement: "Реализуйте алгоритм Кнута-Морриса-Пратта (KMP) для эффективного поиска всех вхождений шаблона (подстроки) в основную строку. Постройте префикс-функцию (pi-массив) для шаблона, затем используйте ее для поиска. Функция должна возвращать список индексов начала вхождений или пустой список, если вхождений нет. Обработайте случаи, когда шаблон пустой или длиннее строки."
  },
  {
    _id: "alg_6",
    subject: Subject.inf,
    theme: "Алгоритмы",
    difficulty: Difficulty.medium,
    title: "Обход графа в ширину (BFS)",
    statement: "Реализуйте поиск в ширину (BFS) для нахождения кратчайшего пути от стартовой вершины до целевой в невзвешенном графе, представленном списком смежности. Используйте очередь для обхода, верните длину пути или -1, если путь не существует. Дополнительно, восстановите сам путь с помощью массива предшественников. Обработайте случаи циклов и несвязных графов."
  },
  {
    _id: "alg_7",
    subject: Subject.inf,
    theme: "Алгоритмы",
    difficulty: Difficulty.medium,
    title: "Обход графа в глубину (DFS)",
    statement: "Используйте рекурсивный обход в глубину (DFS) для проверки ориентированного или неориентированного графа на наличие циклов. Граф представлен списком смежности. Отметьте вершины как посещенные и в процессе посещения, чтобы выявить обратные ребра. Верните true, если цикл найден, иначе false. Обработайте несколько компонент связности и рекурсионный стек для избежания переполнения."
  },
  {
    _id: "alg_8",
    subject: Subject.inf,
    theme: "Алгоритмы",
    difficulty: Difficulty.hard,
    title: "Задача о рюкзаке",
    statement: "Решите классическую задачу о рюкзаке (0/1 Knapsack) методом динамического программирования. Даны массив предметов с весами и стоимостями, а также максимальная вместимость рюкзака. Верните максимальную суммарную стоимость, которую можно унести, не превышая вес. Используйте 2D-таблицу DP или оптимизированную 1D-версию для O(N*W) времени и пространства, где N - число предметов, W - вместимость."
  },
  {
    _id: "alg_9",
    subject: Subject.inf,
    theme: "Алгоритмы",
    difficulty: Difficulty.easy,
    title: "Пузырьковая сортировка",
    statement: "Реализуйте алгоритм сортировки пузырьком для массива целых чисел. Добавьте оптимизацию с флагом, чтобы прервать сортировку, если на проходе не было обменов (массив уже отсортирован). Функция должна сортировать массив на месте и возвращать его. Учитывайте стабильность сортировки и обработку дубликатов."
  },
  {
    _id: "alg_10",
    subject: Subject.inf,
    theme: "Алгоритмы",
    difficulty: Difficulty.medium,
    title: "Сортировка слиянием (Merge Sort)",
    statement: "Реализуйте алгоритм сортировки слиянием (Merge Sort), используя рекурсивное разбиение массива пополам до базового случая (массив из одного элемента), а затем слияние отсортированных подмассивов. Функция должна возвращать новый отсортированный массив, сохраняя стабильность. Обработайте случаи нечетной длины и используйте вспомогательный массив для слияния."
  },

  {
    _id: "sd_1",
    subject: Subject.inf,
    theme: "Структуры данных",
    difficulty: Difficulty.easy,
    title: "Стек (Stack)",
    statement: "Реализуйте структуру данных Стек (LIFO) на базе динамического массива с методами push (добавление элемента сверху), pop (удаление и возврат верхнего элемента) и peek (просмотр верхнего элемента без удаления). Добавьте проверку на пустоту и обработку переполнения (расширение массива при необходимости)."
  },
  {
    _id: "sd_2",
    subject: Subject.inf,
    theme: "Структуры данных",
    difficulty: Difficulty.easy,
    title: "Очередь (Queue)",
    statement: "Реализуйте стандартную очередь (FIFO) на базе массива или связного списка с операциями enqueue (добавление в конец), dequeue (удаление и возврат из начала) и isEmpty (проверка на пустоту). Используйте круговой буфер для оптимизации массива, чтобы избежать сдвигов элементов."
  },
  {
    _id: "sd_3",
    subject: Subject.inf,
    theme: "Структуры данных",
    difficulty: Difficulty.medium,
    title: "Связный список",
    statement: "Создайте класс для односвязного списка с узлами, содержащими данные и ссылку на следующий. Реализуйте метод разворота (reverse) списка за линейное время O(N), изменяя ссылки без дополнительной памяти. Добавьте методы добавления и удаления элементов для полноты."
  },
  {
    _id: "sd_4",
    subject: Subject.inf,
    theme: "Структуры данных",
    difficulty: Difficulty.hard,
    title: "Бинарное дерево поиска (BST)",
    statement: "Реализуйте бинарное дерево поиска (BST) с методами вставки (insert) нового элемента, поиска (search) элемента и симметричного обхода (in-order traversal), который возвращает отсортированный список элементов. Обеспечьте баланс по возможности или отметьте, что дерево не самобалансирующееся. Обработайте дубликаты и удаление (опционально)."
  },
  {
    _id: "sd_5",
    subject: Subject.inf,
    theme: "Структуры данных",
    difficulty: Difficulty.medium,
    title: "Хеш-таблица",
    statement: "Реализуйте простую хеш-таблицу с методом разрешения коллизий через цепочки (связные списки в слотах). Включите методы put (вставка ключ-значение), get (получение по ключу) и remove (удаление по ключу). Используйте хорошую хеш-функцию и обработайте ресайзинг таблицы при нагрузке > 0.75 для поддержания O(1) среднего времени."
  },
  {
    _id: "sd_6",
    subject: Subject.inf,
    theme: "Структуры данных",
    difficulty: Difficulty.medium,
    title: "Приоритетная очередь (Куча)",
    statement: "Реализуйте двоичную мин-кучу (Binary Heap) для эффективного извлечения минимального элемента. Методы: insert (добавление с просачиванием вверх), extractMin (извлечение минимума с просачиванием вниз) и peekMin. Представьте кучу как массив, начиная с индекса 1, и обработайте случаи пустой кучи."
  },
  {
    _id: "sd_7",
    subject: Subject.inf,
    theme: "Структуры данных",
    difficulty: Difficulty.medium,
    title: "Префиксное дерево (Trie)",
    statement: "Реализуйте структуру данных Trie (префиксное дерево) для хранения словаря строк и быстрой проверки наличия слов или префиксов. Методы: insert (добавление слова), search (поиск полного слова) и startsWith (проверка префикса). Каждый узел содержит map потомков по символам и флаг конца слова."
  },
  {
    _id: "sd_8",
    subject: Subject.inf,
    theme: "Структуры данных",
    difficulty: Difficulty.hard,
    title: "LRU Кэш",
    statement: "Спроектируйте структуру данных 'LRU Cache' (Least Recently Used), которая хранит ключ-значение с фиксированной емкостью и вытесняет наименее используемые элементы при достижении лимита. Используйте хеш-мап и двусвязный список для O(1) операций get и put. При get перемещайте элемент в начало списка (самый недавно использованный)."
  },
  {
    _id: "sd_9",
    subject: Subject.inf,
    theme: "Структуры данных",
    difficulty: Difficulty.medium,
    title: "Двусвязный список",
    statement: "Реализуйте двусвязный список с узлами, содержащими данные, ссылки на предыдущий и следующий. Добавьте метод удаления узла за константное время O(1), если дана ссылка на удаляемый узел (обновите ссылки соседей). Включите методы добавления в начало/конец и итерацию для полноты."
  },
  {
    _id: "sd_10",
    subject: Subject.inf,
    theme: "Структуры данных",
    difficulty: Difficulty.hard,
    title: "Система непересекающихся множеств (DSU)",
    statement: "Реализуйте структуру данных Disjoint Set Union (DSU) с оптимизациями: сжатие путей (path compression) для быстрого find и union by rank (ранговая эвристика) для баланса деревьев. Методы: find (найти представителя множества) и union (объединить два множества). Инициализируйте для N элементов и обработайте случаи уже объединенных множеств."
  }
];